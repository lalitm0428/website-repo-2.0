# Netflix Data Analysis Project Guide

This guide provides step-by-step instructions and code snippets to perform a complete data analysis pipeline on the Netflix dataset.

## Project Structure

It is recommended to organize your project as follows:

```text
Netlfix_Project/
├── Data/
│   └── netflix_dataset.csv  <-- Your source file
├── Notebooks/
│   ├── 1_Data_Cleaning.ipynb
│   ├── 2_Data_Analysis.ipynb
│   ├── 3_Data_Visualization.ipynb
│   └── 4_Predictive_Analysis.ipynb
└── Output/
    └── netflix_cleaned.csv  <-- Generated by Notebook 1
```

## Prerequisites

You will need to install the following Python libraries. Run this in your terminal or a notebook cell:

```bash
pip install pandas numpy matplotlib seaborn plotly scikit-learn
```

---

## Notebook 1: Data Cleaning

**Goal:** Prepare the raw dataset for analysis by handling missing values and formatting data types.

**Step 1: Load and Inspect Data**
```python
import pandas as pd
import numpy as np

# Load the dataset
file_path = "/Users/apple/Documents/Uni/Personal /Netlfix_Project/Data/netflix_dataset.csv"
df = pd.read_csv(file_path)

# Inspect initial data
print(df.info())
print(df.isnull().sum())
```

**Step 2: Handle Missing Values**
```python
# Fill missing values for categorical columns
df['director'] = df['director'].fillna('No Director')
df['cast'] = df['cast'].fillna('No Cast')
df['country'] = df['country'].fillna('Country Unavailable')

# Drop rows where critical data is missing (small percentage)
df.dropna(subset=['date_added', 'rating'], inplace=True)
```

**Step 3: Date Formatting and Feature Extraction**
```python
# Convert 'date_added' to datetime
# The strip() removes any leading/trailing whitespace that might cause errors
df['date_added'] = pd.to_datetime(df['date_added'].str.strip())

# Extract Year and Month for analysis
df['year_added'] = df['date_added'].dt.year
df['month_added'] = df['date_added'].dt.month_name()
```

**Step 4: Save Cleaned Data**
```python
# Save to a new CSV for the next notebooks
df.to_csv('../Output/netflix_cleaned.csv', index=False)
print("Data cleaned and saved to 'netflix_cleaned.csv'")
```

---

## Notebook 2: Data Analysis

**Goal:** Perform Exploratory Data Analysis (EDA) to understand distributions and trends.

**Step 1: Load Cleaned Data**
```python
import pandas as pd
df = pd.read_csv('../Output/netflix_cleaned.csv')
```

**Step 2: Analyze Content Types**
```python
# Ratio of Movies vs TV Shows
type_counts = df['type'].value_counts()
print("Content Types:\n", type_counts)

# Calculate percentage
type_ratios = df['type'].value_counts(normalize=True) * 100
print("\nContent Ratios (%):\n", type_ratios)
```

**Step 3: Analyze Content by Country**
```python
# Top 10 countries producing content
top_countries = df['country'].value_counts().head(10)
print("\nTop 10 Countries:\n", top_countries)
```

**Step 4: Analyze Ratings**
```python
# Most common ratings
rating_counts = df['rating'].value_counts()
print("\nRatings Distribution:\n", rating_counts)
```

---

## Notebook 3: Data Visualization

**Goal:** Create visual representations of the data, including advanced 3D charts and heatmaps.

**Step 1: Setup**
```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px  # For 3D plots

df = pd.read_csv('../Output/netflix_cleaned.csv')
```

**Step 2: Heatmap of Content Added**
This visualizes the density of content added over time (Month vs Year).

```python
# Prepare data for heatmap
# We filter for recent years to keep the chart readable
df_recent = df[df['year_added'] >= 2015]

month_order = ['January', 'February', 'March', 'April', 'May', 'June', 
               'July', 'August', 'September', 'October', 'November', 'December']

heatmap_data = df_recent.groupby('year_added')['month_added'].value_counts().unstack().fillna(0)
heatmap_data = heatmap_data[month_order] # Reorder columns

plt.figure(figsize=(12, 6))
sns.heatmap(heatmap_data.T, cmap="YlGnBu", annot=True, fmt='g')
plt.title('Content Added by Month and Year')
plt.xlabel('Year')
plt.ylabel('Month')
plt.show()
```

**Step 3: 3D Scatter Plot (Interactive)**
Visualizing the relationship between Release Year, Duration, and Rating for Movies.

```python
# Filter for Movies only
movies = df[df['type'] == 'Movie'].copy()

# Drop rows with missing duration to avoid errors
movies.dropna(subset=['duration'], inplace=True)

# Clean duration to get integer minutes
movies['duration_min'] = movies['duration'].str.replace(' min', '').astype(int)

# Create 3D Plot
fig = px.scatter_3d(movies, 
                    x='release_year', 
                    y='duration_min', 
                    z='year_added',
                    color='rating',
                    hover_name='title',
                    title='3D View: Release Year vs Duration vs Added Year',
                    opacity=0.7)
fig.show()
```

**Step 4: Distribution Charts**
```python
# Content Type Distribution
plt.figure(figsize=(6, 6))
plt.pie(df['type'].value_counts(), labels=df['type'].value_counts().index, autopct='%1.1f%%', colors=['#E50914', '#221f1f'])
plt.title('Distribution of Content Types')
plt.show()
```

---

## Notebook 4: Predictive Analysis & Regression

**Goal:** Use Machine Learning to classify content and perform regression analysis.

**Step 1: Setup and Preprocessing**
```python
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.metrics import classification_report, mean_squared_error, r2_score
from sklearn.preprocessing import LabelEncoder

df = pd.read_csv('../Output/netflix_cleaned.csv')
```

**Task A: Classification (Predict 'Type' based on Description)**
Can we predict if a title is a Movie or TV Show just by reading its description?

```python
# 1. Prepare Data
tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
X = tfidf.fit_transform(df['description'])
y = df['type']

# 2. Split Data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 3. Train Model
clf = LogisticRegression()
clf.fit(X_train, y_train)

# 4. Evaluate
y_pred = clf.predict(X_test)
print("Classification Report (Type Prediction):\n")
print(classification_report(y_test, y_pred))
```

**Task B: Regression (Predict Movie Duration based on Release Year)**
Is there a trend in movie length over the years? Let's try to predict duration based on the year it was released.

```python
# 1. Prepare Data (Movies only)
movies = df[df['type'] == 'Movie'].copy()
movies['duration_min'] = movies['duration'].str.replace(' min', '').astype(int)

# We will use Release Year to predict Duration
X_reg = movies[['release_year']]
y_reg = movies['duration_min']

# 2. Split Data
X_train_r, X_test_r, y_train_r, y_test_r = train_test_split(X_reg, y_reg, test_size=0.2, random_state=42)

# 3. Train Model
reg = LinearRegression()
reg.fit(X_train_r, y_train_r)

# 4. Evaluate
y_pred_r = reg.predict(X_test_r)

print("Regression Analysis (Duration Prediction):")
print(f"Mean Squared Error: {mean_squared_error(y_test_r, y_pred_r):.2f}")
print(f"R2 Score: {r2_score(y_test_r, y_pred_r):.4f}")
print(f"Coefficient (Trend): {reg.coef_[0]:.4f}") 
# A negative coefficient would imply movies are getting shorter over time
```